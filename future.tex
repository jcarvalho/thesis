\chapter{Future Work}

The solution proposed in this document, despite providing great
improvements over existing solutions, still presents several
challenges. This chapter presents a few modifications which would
greatly enhance the solution, making it both more user and developer
friendly. 

\section{Extending to other backends}

At the time this document was written, only a handful of Fenix
Framework backends were able to take advantage of the improvements for
Long Lived Transactions.

This is greatly in part because the implementation requires
multi-versioning support, meaning that when a new value is written for
a given box, its previous value cannot be Garbage Collected. 

For in-memory backends this doesn't pose much of a problem, as those
backends are typically used for testing and demonstrations, and as
such deal with a small data set, making it easy to fit all versions in
memory. 

Backends with persistence support on the other hand, are greatly
affected by this requirement. By storing every version persistently,
the size of the database (in whatever technology it may be: SQL,
NoSQL, text files, etc) will grow uncontrollably. Consider an
application containing a {\it User} entity, with a slot containing the
last time the user logged in. In the extreme case, the whole {\it
  User} object would be replicated each time the user logged in to the
application.

To cope with this growth rate, a Garbage Collection system would have
to be created. Assuming that Long Lived Transactions are the only
reason for multi-versioning (which in practice may not be so), such a
system could be developed.

The system would have to scan all pending Long Lived Transactions,
find the oldest one (i.e. the one with the smallest version number),
and scour through the whole database, removing entries older than such
a version. A naive approach however may not be sufficient, as stale
transactions (i.e. not accessed for a long time) would leave the old
versions sitting around for an indefinite amount of time.

An automated approach to take care of stale transactions would then be
needed. The solution for this issue is far from trivial, as a Long
Lived Transaction represents a user's Unit of Work, and as such can't
be blindly removed. However, as old transactions are likely to be in
conflict, it would should be safe to discard those, presenting the
user with a summary of the changes performed by the Long Lived
Transaction. Section \ref{sec:conflicts} briefly discusses this in
regard to conflict resolution.

However, there is a possible solution that doesn't require
multi-versioning. This solution would restrict the programming model,
by forcing the programmer to read every piece of data within the first
transaction step, thus ensuring that the read-set is filled within the
first step (whose version number is chosen for the transaction). The
Read Set would also have to store the read value (in a way similar to
the Write Set), ensuring that all reads could be satisfied.

\section{Conflict Management}
\label{sec:conflicts}

Perhaps the biggest limitation of this solution is conflict
management. Unlike a regular transaction, a typical Long Lived
Transaction has a greater duration and size, thus increasing both the
probability of conflits and the amount of lost work in case of a
conflict.

The solution proposed so far focuses solely in strict correctness,
providing no mechanisms for conflict reduction and handling. This
section presents some ideas to solve those issues. It is divided in
two main areas: reducing conflicts altogether, and improving the way
conflicts are handled.

\subsection{Reducing Conflicts}

Consider the Course creation scenario presented in previous
chapters. Now consider that the application used to create such
Courses uses domain objects to represent the structure of the
application's menu. With the current implementation of Long Lived
Transactions, any change to one of the menu items would cause the
Course creation to be rolled back!

This is because rendering the Course creation page would read the
domain objects used to represent the items in the menu (so it could be
rendered), putting them in the read set, despite the fact that they
are not directly related to the operation the user is performing.

A possible approach would be to extend the DML to allow the programmer
to specify specific classes or slots to have their transactional
properties relaxed in Long Lived Transactions.

Those classes would still be added to the read set of the Long Lived
Transaction, however, the transaction would not conflict even if the
read version is previous than the current version, unless the box has
been written by the transaction (to avoid dirty writes). This would
require special care from the programmer, as it makes it possible to
perform operations based on an old version of a part of the data.

Another possibility is to take advantage of restartable
transactions. Restartable transactions were first introduced in the
JVSTM in \cite{cachopo2006versioned}, and was explored in more detail
in \cite{BrunoJorgeGasparFranco2013}.

Restartable transactions are presented as programmer-defined portions
of a larger transaction.

CONTINUAR

\subsection{Handling Conflicts}

In the proposed solution, when a conflict happens the only possible
course of action is to rollback, as it is not possible to restart the
whole transaction.

If the detected conflict isn't recoverable, it is up to the user to
determine whether the written data can actually be merged with the
global context. As such, handling conflicts in Long Lived Transactions
is more of a User Interaction problem than an infrastructural problem.

An interface could be devised, showing the end-user what data was
written in the transaction, and the conflicting read data, similar to
existing conflict resolution tools (such as Meld and Git's conflict
resolution mechanism).

The user could then analyse that data to determine whether the
conflicts are relevant according to the business rules, and choose to
rollback the Transaction, to merge parts of the written data or to
simply commit the operation.

Giving users so much power (as this solution could allow them to
deliberately leave the system in an inconsistent state) is
dangerous. Should the interface be poorly designed, it would be simple
for a user to perform the wrong action. It requires a great deal of
analysis, user testing and interaction testing.
